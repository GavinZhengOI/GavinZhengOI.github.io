<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CF976F Minimal k-covering | GVZ&#39;s Blog</title>
<link rel="shortcut icon" href="https://wzmhtr.coding-pages.com/favicon.ico?v=1615816506689">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://wzmhtr.coding-pages.com/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CF976F Minimal k-covering | GVZ&#39;s Blog - Atom Feed" href="https://wzmhtr.coding-pages.com/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="因为限制是“至少被k条边覆盖”，不太好搞，我们把它转化成，&quot;对于点u，至多选择degreeu−kdegree_u-kdegreeu​−k条边不覆盖&quot;。而这个“至多”的限制，就可以看作是流量。所以建图很好建。
类似这样：
..." />
    <meta name="keywords" content="网络流" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://wzmhtr.coding-pages.com">
  <img class="avatar" src="https://wzmhtr.coding-pages.com/images/avatar.png?v=1615816506689" alt="">
  </a>
  <h1 class="site-title">
    GVZ&#39;s Blog
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://wzmhtr.coding-pages.com/post/you-lian" class="menu">
          友链
        </a>
      
    
      
        <a href="https://wzmhtr.coding-pages.com/post/tou-wen-jian-ji-hong-ding-yi" class="menu">
          头文件
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/GavinZhengOI" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://twitter.com/yIIJfce0wywQQOb" target="_blank">
          <i class="ri-twitter-line"></i>
        </a>
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CF976F Minimal k-covering
            </h2>
            <div class="post-info">
              <span>
                2021-01-16
              </span>
              <span>
                6 min read
              </span>
              
                <a href="https://wzmhtr.coding-pages.com/tag/fOZFkkAE-Y/" class="post-tag">
                  # 网络流
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>因为限制是“至少被k条边覆盖”，不太好搞，我们把它转化成，&quot;对于点u，至多选择<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>g</mi><mi>r</mi><mi>e</mi><msub><mi>e</mi><mi>u</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">degree_u-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>条边不覆盖&quot;。而这个“至多”的限制，就可以看作是流量。所以建图很好建。<br>
类似这样：<br>
<img src="https://i.loli.net/2021/01/16/9ZtXyCTLjwKvNz7.png" alt="" loading="lazy"><br>
但是有个问题，如果对于所有的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>都暴力重新跑一遍，复杂度最坏是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>m</mi><msqrt><mi>n</mi></msqrt><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(m\sqrt n)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>的显然不太行。但是我们注意到这道题有个特殊的性质：最大流的最大值是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>。所以最多只会增广<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>次，单次增广的复杂度显然是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>的。最后算下来总复杂度应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(n+m)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>的。</p>
<pre><code class="language-cpp">/*
                                                  
  _|_|                              _|  _|    _|  
_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|    
_|    _|  _|_|          _|          _|  _|_|      
_|    _|  _|          _|      _|    _|  _|  _|    
  _|_|    _|        _|_|_|_|    _|_|    _|    _|  
                                                                                                    
*/ 
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
//#define ls (rt&lt;&lt;1)
//#define rs (rt&lt;&lt;1|1)
#define vi vector&lt;int&gt;
#define pb push_back
#define mk make_pair
#define pii pair&lt;int,int&gt;
#define rep(i,a,b) for(int i=(a),i##end=(b);i&lt;=i##end;i++)
#define fi first
#define se second
typedef long long ll;
using namespace std;
const int maxn=2*2e3+100;
const int base=2000;
const int s=maxn-2,t=maxn-1;
const int inf=1e9+100;
int head[maxn];
pii ori[maxn];
int cnt=1;
struct gg{
	int u,v,w,idx,next;
}side[maxn*4];
void ins(int u,int v,int w,int idx){
	side[++cnt]=(gg){u,v,w,idx,head[u]};head[u]=cnt;
	side[++cnt]=(gg){v,u,0,idx,head[v]};head[v]=cnt;
}
int d[maxn];
vector&lt;vi&gt;ans;
int cur[maxn],rk[maxn];
queue&lt;int&gt;q;
bool bfs(){
	memset(rk,0,sizeof(rk));while(!q.empty())q.pop();
	q.push(s);rk[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=head[u];i;i=side[i].next){
			int v=side[i].v;if(rk[v]||!side[i].w)continue;
			rk[v]=rk[u]+1;q.push(v);
		}
	}
	if(rk[t])return 1;
	return 0;
}
int dfs(int u,int flow){
	if(u==t||!flow)return flow;
	int tot=0;
	for(int &amp;i=cur[u];i;i=side[i].next){
		int v=side[i].v;if(side[i].w&lt;=0||rk[v]!=rk[u]+1)continue;
		int sent=dfs(v,min(flow,side[i].w));
		//cout&lt;&lt;v&lt;&lt;&quot;----------&gt;&quot;&lt;&lt;u&lt;&lt;&quot;   flow=&quot;&lt;&lt;sent&lt;&lt;endl;
		flow-=sent,tot+=sent;side[i].w-=sent,side[i^1].w+=sent;
		if(!flow)break;
	}
	return tot;
}
void dinic(){
	while(bfs()){
		memcpy(cur,head,sizeof(head));
		dfs(s,inf);		
	}
}
int n1,n2,m;
void debug(){
	rep(i,1,n1)for(int j=head[i];j;j=side[j].next)cout&lt;&lt;&quot;&gt;&gt;&quot;&lt;&lt;side[j].u&lt;&lt;' '&lt;&lt;side[j].v&lt;&lt;' '&lt;&lt;side[j].w&lt;&lt;endl;
	rep(i,1,n2)for(int j=head[i+base];j;j=side[j].next)cout&lt;&lt;&quot;&gt;&gt;&quot;&lt;&lt;side[j].u&lt;&lt;' '&lt;&lt;side[j].v&lt;&lt;' '&lt;&lt;side[j].w&lt;&lt;endl;
	for(int j=head[s];j;j=side[j].next)cout&lt;&lt;&quot;&gt;&gt;&quot;&lt;&lt;side[j].u&lt;&lt;' '&lt;&lt;side[j].v&lt;&lt;' '&lt;&lt;side[j].w&lt;&lt;endl;
	cout&lt;&lt;&quot;END&quot;&lt;&lt;endl;
}
int main(){
	ios::sync_with_stdio(0);
	cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;
	int mi_d=1e9,mx_d=0;
	rep(i,1,m){
		int u,v;cin&gt;&gt;u&gt;&gt;v;ori[i]=mk(u,v);d[u]++,d[v+base]++;
		ins(u,v+base,1,i);
	}
	rep(i,1,n1)mi_d=min(mi_d,d[i]),mx_d=max(mx_d,d[i]);
	rep(i,1,n2)mi_d=min(mi_d,d[i+base]),mx_d=max(mx_d,d[i+base]);
	//容量 \in [u_degree-mi_degree,u_degree];
	rep(i,1,n1){
		ins(s,i,d[i]-mi_d-1,0);
	}
	rep(i,1,n2){
		ins(i+base,t,d[i+base]-mi_d-1,0);
	}
	
	//debug();
	for(int k=mi_d;k&gt;=0;k--){
		for(int i=head[s];i;i=side[i].next){
			//int v=side[i].v;
			if(!side[i].idx)side[i].w++;
		}
		rep(i,1,n2){
			for(int j=head[i+base];j;j=side[j].next){
				int v=side[j].v;
				if(!side[j].idx&amp;&amp;v==t)side[j].w++;
			}
		}
	//	debug();
		dinic();
		vi tmp;vi jk;
		rep(gg,base+1,base+n2)for(int i=head[gg];i;i=side[i].next)
		if(side[i].idx&amp;&amp;side[i].v&lt;=n1&amp;&amp;side[i].w)
		tmp.pb(side[i].idx);
		sort(tmp.begin(),tmp.end());
		int now=0;
		rep(i,1,m){
			if(now&lt;tmp.size()&amp;&amp;tmp[now]==i){
				now++;continue;
			}
			jk.pb(i);
		}
		ans.pb(jk);
	}
	for(int i=ans.size()-1;i&gt;=0;i--){
		vi tmp=ans[i];cout&lt;&lt;tmp.size()&lt;&lt;' ';
		rep(j,0,tmp.size()-1)cout&lt;&lt;tmp[j]&lt;&lt;' ';
		cout&lt;&lt;endl;
	}
	return 0;
}

</code></pre>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://wzmhtr.coding-pages.com/post/cf587e-duff-as-a-queen/">
              <h3 class="post-title">
                CF587E Duff as a Queen
              </h3>
            </a>
          </div>
        

        
          

          
            <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css">
<script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>

<div id="disqus_thread"></div>

<script>

var options = {
  shortname: 'gvablog',
  apikey: 'GaTDI1iKdBspu9eatH3bb3vkRipD45khhPrE1OZvNtqC43gwRa22Noy6Yx2WW1YQ',
}
if ('https://disqus.skk.moe/disqus/') {
  options.api = 'https://disqus.skk.moe/disqus/'
}
var dsqjs = new DisqusJS(options)

</script>

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://wzmhtr.coding-pages.com/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
