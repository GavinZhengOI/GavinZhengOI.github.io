<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wzmhtr.coding-pages.com</id>
    <title>GVZ&apos;s Blog</title>
    <updated>2021-03-14T09:50:33.579Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wzmhtr.coding-pages.com"/>
    <link rel="self" href="https://wzmhtr.coding-pages.com/atom.xml"/>
    <logo>https://wzmhtr.coding-pages.com/images/avatar.png</logo>
    <icon>https://wzmhtr.coding-pages.com/favicon.ico</icon>
    <rights>All rights reserved 2021, GVZ&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[最短路问题-CF1442C Graph Transpositions]]></title>
        <id>https://wzmhtr.coding-pages.com/post/zui-duan-lu-wen-ti-cf1442c-graph-transpositions/</id>
        <link href="https://wzmhtr.coding-pages.com/post/zui-duan-lu-wen-ti-cf1442c-graph-transpositions/">
        </link>
        <updated>2021-03-14T09:44:10.000Z</updated>
        <content type="html"><![CDATA[<p>最近开了道CF1442C，感觉还是要总结一下最短路类型题的一些特征，这样写的时候能快一点。</p>
<p>个人感觉最短路其实是一种变相的动态规划。无论转移方式整什么花活，套路还是差不多的。我们把二元组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">路</mi><mi mathvariant="normal">径</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">息</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(位置，路径信息)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">置</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">径</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">息</span><span class="mclose">)</span></span></span></span>称为一个状态。对于每一个位置，我们只需要记录下那条最优秀的路径信息即可。这也就是普通的最短路。</p>
<p>但是有些时候</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1033E Hidden Bipartite Graph]]></title>
        <id>https://wzmhtr.coding-pages.com/post/cf1033e-hidden-bipartite-graph/</id>
        <link href="https://wzmhtr.coding-pages.com/post/cf1033e-hidden-bipartite-graph/">
        </link>
        <updated>2021-03-03T12:53:27.000Z</updated>
        <content type="html"><![CDATA[<p>题目中只能询问一个集合内部的边，我们先考虑如何询问一个点到其他点的边，显然可以把这个询问拆成两个询问，然后我们发现可以在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\log_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span></span></span></span>的时间内寻找一个点的任意一条出边（二分）。所以我们考虑先整出一个dfs树。复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>n</mi><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">2*n\log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p>
<p>这样我们就得到了二分图的“两半”。只需要询问一下两半内部有没有边就能确定是否是二分图。如果是就直接输出。不是的话则遍历内部有边的那一半节点，然后依次询问每个点出发到自己所在的一半有没有边，有边的话暴力找出即可。复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>n</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2*n+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p>
<p>计算得出最坏需要<code>13800</code>次询问，符合要求。</p>
<pre><code class="language-cpp">/*
                                                  
  _|_|                              _|  _|    _|  
_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|    
_|    _|  _|_|          _|          _|  _|_|      
_|    _|  _|          _|      _|    _|  _|  _|    
  _|_|    _|        _|_|_|_|    _|_|    _|    _|  
                                                                                                    
*/ 
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
//#define ls (rt&lt;&lt;1)
//#define rs (rt&lt;&lt;1|1)
#define vi vector&lt;int&gt;
#define pb push_back
#define mk make_pair
#define pii pair&lt;int,int&gt;
#define rep(i,a,b) for(int i=(a),i##end=(b);i&lt;=i##end;i++)
#define fi first
#define se second
typedef long long ll;
using namespace std;
const int maxn=605;
int nask(vi tmp){
	if(!tmp.size()||tmp.size()==1)return 0;
	cout&lt;&lt;&quot;? &quot;&lt;&lt;tmp.size()&lt;&lt;endl;
	rep(i,0,(int)tmp.size()-1)cout&lt;&lt;tmp[i]&lt;&lt;' ';
	cout&lt;&lt;endl;
	cout.flush();
	int ans;cin&gt;&gt;ans;
	if(ans==-1)exit(0);
	return ans;
}
int dask(int u,vi tar){
	int cntsig=nask(tar);tar.pb(u);
	int cnttot=nask(tar);
	return cnttot-cntsig;
}
int n;
bool vis[maxn];
int bl[maxn];
int find(int u,vi tmp){
	vi c1,c2;
	if(tmp.size()==1)return tmp[0];
	rep(i,0,(int)(tmp.size())-1){
		if(c1.size()&lt;tmp.size()/2)c1.pb(tmp[i]);
		else c2.pb(tmp[i]);
	}
	if(dask(u,c1))return find(u,c1);
	else return find(u,c2);
}
vi half[2];
vi side[maxn];
void dfs(int u){
	half[bl[u]].pb(u);
	while(1){
		vi tmp;rep(i,1,n)if(!vis[i])tmp.pb(i);
		if(dask(u,tmp)==0)return;
		int tar=find(u,tmp);side[u].pb(tar);side[tar].pb(u);
	//	cout&lt;&lt;&quot;&gt;&gt;&gt;&quot;&lt;&lt;u&lt;&lt;&quot;----&gt;&quot;&lt;&lt;tar&lt;&lt;endl;
		vis[tar]=1;bl[tar]=bl[u]^1;dfs(tar);
	}
}
int stk[maxn],top;
vi ans;
void cfs(int u,int tar){
	stk[++top]=u;
	if(u==tar){
		rep(i,1,top)ans.pb(stk[i]);
		return;
	}
	rep(i,0,side[u].size()-1){
		int v=side[u][i];
		if(!vis[v]){
			vis[v]=1;
			cfs(v,tar);
		}
	}
	top--;
}
void ans_out(int u,int v){
	memset(vis,0,sizeof(vis));
	vis[u]=1;cfs(u,v);
	cout&lt;&lt;&quot;N &quot;&lt;&lt;ans.size()&lt;&lt;endl;
	rep(i,0,(int)(ans.size())-1)cout&lt;&lt;ans[i]&lt;&lt;' ';
	return;
}
int main(){
//	freopen(&quot;in&quot;,&quot;r&quot;,stdin);
	ios::sync_with_stdio(0);
	cin&gt;&gt;n;
	vis[1]=1;dfs(1);
	if(!nask(half[0])&amp;&amp;!nask(half[1])){
		cout&lt;&lt;&quot;Y &quot;&lt;&lt;half[0].size()&lt;&lt;endl;
		rep(i,0,(int)(half[0].size())-1)cout&lt;&lt;half[0][i]&lt;&lt;' ';
		return 0;
	}
	else{
		rep(i,0,1)rep(j,0,(int)(half[i].size())-1){
			vi tmp;int u=half[i][j];
			rep(k,0,(int)(half[i].size())-1)if(half[i][k]!=u)tmp.pb(half[i][k]);
			if(dask(u,tmp)){
				rep(k,0,(int)(tmp.size())-1){
					vi gg;gg.pb(u);gg.pb(tmp[k]);
					if(nask(gg)){
						ans_out(u,tmp[k]);return 0;
					}
				}
			}
		}
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1061E Politics]]></title>
        <id>https://wzmhtr.coding-pages.com/post/cf1061e-politics/</id>
        <link href="https://wzmhtr.coding-pages.com/post/cf1061e-politics/">
        </link>
        <updated>2021-03-02T00:01:14.000Z</updated>
        <content type="html"><![CDATA[<p>我们思考一下这个问题的性质。因为限制是：子树内被标记的点的个数。同时子树内所有以有限制的点为根的子树，标记点数量都是确定的。所以我们发现，一个点<code>x</code>是否选择，对且只对一个点<code>f</code>的限制是否满足有影响，这个点<code>f</code>就是<code>x</code>在树上最近的有限制的父亲。所以我们把<code>x</code>是否选择交给<code>f</code>来决定。这种限制以及数据范围提示我们费用流。</p>
<p>建图就很好建了。对于每个有限制的点<code>i</code>，连边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>−</mo><mo>&gt;</mo><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S-&gt; i_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，费用为0容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><msub><mi>m</mi><mi>i</mi></msub><mo>−</mo><mo>∑</mo><msub><mi>i</mi><mn>1</mn></msub><mi mathvariant="normal">在</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">树</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">控</mi><mi mathvariant="normal">制</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">已</mi><mi mathvariant="normal">经</mi><mi mathvariant="normal">确</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">小</mi></mrow><annotation encoding="application/x-tex">lim_i-\sum i_1在子树内不能控制的点的已经确定的大小</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">树</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">控</span><span class="mord cjk_fallback">制</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">已</span><span class="mord cjk_fallback">经</span><span class="mord cjk_fallback">确</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">小</span></span></span></span>，另一边连边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub><mo>−</mo><mo>&gt;</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">i_2-&gt;T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>同理，容量调整为树2的限制即可。</p>
<p>我们现在已经满足了两棵树上所有限制点的合法（树1每个点流入，树2每个点流出的流量都等于他们各自控制的点集中选择了的点的个数）。然后我们考虑怎么把两棵树联系起来计算贡献。对于一个点<code>i</code>在树1和树2上的映射<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(i1,i2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，代表他们两个点是否选择的流量都在距离他们最近的有限制的父亲中，记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>f</mi><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>f</mi><msub><mi>a</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(fa_1,fa_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。那我们就连一条边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><msub><mi>a</mi><mn>1</mn></msub><mo>−</mo><mo>&gt;</mo><mi>f</mi><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">fa_1-&gt;fa_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，容量为1，费用为其贡献，这条边流过就代表选择点<code>i</code>，然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>f</mi><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">fa_1,fa_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>限制都要-1。</p>
<p>最后跑最大费用最大流即可。</p>
<pre><code class="language-cpp">/*
                                                  
  _|_|                              _|  _|    _|  
_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|    
_|    _|  _|_|          _|          _|  _|_|      
_|    _|  _|          _|      _|    _|  _|  _|    
  _|_|    _|        _|_|_|_|    _|_|    _|    _|  
                                                                                                    
*/ 
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
//#define ls (rt&lt;&lt;1)
//#define rs (rt&lt;&lt;1|1)
#define vi vector&lt;int&gt;
#define pb push_back
#define mk make_pair
#define pii pair&lt;int,int&gt;
#define rep(i,a,b) for(int i=(a),i##end=(b);i&lt;=i##end;i++)
#define fi first
#define se second
typedef long long ll;
using namespace std;
const int maxn=2*505;
const int base=505;
const int S=maxn-2;
const int T=maxn-3;
int a[maxn];
vi ori[2][maxn];
int head[maxn],cnt=1;
struct gg{
	int u,v,w,cost,next;
}side[(maxn*3)*2+1000];
int size[2][maxn];
int lim[2][maxn];
int n,x,y,q1,q2;
int f[2][maxn];
void dfs1(int u,int fa,int floor){
	size[floor][u]=1;f[floor][u]=fa;
	rep(i,0,ori[floor][u].size()-1){
		int v=ori[floor][u][i];if(v==fa)continue;
		dfs1(v,u,floor);size[floor][u]+=size[floor][v];
	}
}
void ins(int u,int v,int w,int cost){
	side[++cnt]=(gg){u,v,w,cost,head[u]};head[u]=cnt;
	side[++cnt]=(gg){v,u,0,-cost,head[v]};head[v]=cnt;
//	cout&lt;&lt;u&lt;&lt;' '&lt;&lt;v&lt;&lt;' '&lt;&lt;cost&lt;&lt;endl;
}
int flag=-1;
int dfs2(int u,int fa,int floor){
	if(lim[floor][u]&amp;&amp;flag!=u)return lim[floor][u];
	int res=0;
	rep(i,0,ori[floor][u].size()-1){
		int v=ori[floor][u][i];if(v==fa)continue;
		res+=dfs2(v,u,floor);
	}
	return res;
}
ll ans;

int dis[maxn];
int inf=2e9;
queue&lt;int&gt;q;
int vis[maxn];
bool spfa(int s,int t){
	memset(dis,-0x3f,sizeof(dis));while(!q.empty())q.pop();
	dis[s]=0;vis[s]=1;q.push(s);
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=head[u];i;i=side[i].next){
			int v=side[i].v,val=side[i].cost;
			if(dis[u]+val&gt;dis[v]&amp;&amp;side[i].w&gt;0){
				dis[v]=dis[u]+val;
				if(!vis[v]){vis[v]=1;q.push(v);}
			}
		}
	}
	if(dis[t]&lt;-1e8)return 0;
	return 1;
}
int cur[maxn];
int dfs3(int u,int flow){
	if(u==T)return flow;
	vis[u]=1;
	int used=0;
	for(int &amp;i=cur[u];i&amp;&amp;used&lt;flow;i=side[i].next){
		int v=side[i].v,w=side[i].w,cost=side[i].cost;
		if(!vis[v]&amp;&amp;dis[u]+cost==dis[v]&amp;&amp;w){
			int send=dfs3(v,min(w,flow-used));
			ans+=1ll*send*cost;
			side[i].w-=send;side[i^1].w+=send;used+=send;
		}
	}
	vis[u]=0;
	return used;
}
int mcfx(){
	int mxflow=0;
	while(spfa(S,T)){
		memcpy(cur,head,sizeof(cur));	
		mxflow+=dfs3(S,inf);
	}
	return mxflow;
}
int main(){
	ios::sync_with_stdio(0);
	cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;
	rep(i,1,n)cin&gt;&gt;a[i];
	rep(i,1,n-1){int u,v;cin&gt;&gt;u&gt;&gt;v;ori[0][u].pb(v);ori[0][v].pb(u);}
	rep(i,1,n-1){int u,v;cin&gt;&gt;u&gt;&gt;v;ori[1][u].pb(v);ori[1][v].pb(u);}
	cin&gt;&gt;q1;rep(i,1,q1){int k;cin&gt;&gt;k;cin&gt;&gt;lim[0][k];}
	cin&gt;&gt;q2;rep(i,1,q2){int k;cin&gt;&gt;k;cin&gt;&gt;lim[1][k];}
	dfs1(x,0,0);dfs1(y,0,1);
//	if(!lim[0][x])lim[0][x]=inf;
//	if(!lim[1][y])lim[1][y]=inf;
	rep(i,1,n){
		flag=i;
		if(lim[0][i]){
			ins(S,i,lim[0][i]-dfs2(i,f[0][i],0),0);
			//ins(i,S,0,0);
		}
		if(lim[1][i]){
			ins(i+base,T,lim[1][i]-dfs2(i,f[1][i],1),0);
		//	ins(T,i+base,0,0);
		}
		flag=-1;
		int fa1=i,fa2=i;
		while(!lim[0][fa1]&amp;&amp;fa1!=x){fa1=f[0][fa1];}
		while(!lim[1][fa2]&amp;&amp;fa2!=y){fa2=f[1][fa2];}
		//cout
		ins(fa1,fa2+base,1,a[i]);
	//	ins(fa2+base,fa1,0,-a[i]);
	}
	mcfx();
	for(int i=head[S];i;i=side[i].next){
		if(side[i].w){cout&lt;&lt;&quot;-1&quot;;return 0;}
	}
	for(int i=head[T];i;i=side[i].next){
		if(side[i^1].w){cout&lt;&lt;&quot;-1&quot;;return 0;}
	}
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF976F Minimal k-covering]]></title>
        <id>https://wzmhtr.coding-pages.com/post/cf976f-minimal-k-covering/</id>
        <link href="https://wzmhtr.coding-pages.com/post/cf976f-minimal-k-covering/">
        </link>
        <updated>2021-01-15T23:40:42.000Z</updated>
        <content type="html"><![CDATA[<p>因为限制是“至少被k条边覆盖”，不太好搞，我们把它转化成，&quot;对于点u，至多选择<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>g</mi><mi>r</mi><mi>e</mi><msub><mi>e</mi><mi>u</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">degree_u-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>条边不覆盖&quot;。而这个“至多”的限制，就可以看作是流量。所以建图很好建。<br>
类似这样：<br>
<img src="https://i.loli.net/2021/01/16/9ZtXyCTLjwKvNz7.png" alt="" loading="lazy"><br>
但是有个问题，如果对于所有的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>都暴力重新跑一遍，复杂度最坏是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>m</mi><msqrt><mi>n</mi></msqrt><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(m\sqrt n)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>的显然不太行。但是我们注意到这道题有个特殊的性质：最大流的最大值是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>。所以最多只会增广<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>次，单次增广的复杂度显然是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>的。最后算下来总复杂度应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(n+m)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>的。</p>
<pre><code class="language-cpp">/*
                                                  
  _|_|                              _|  _|    _|  
_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|    
_|    _|  _|_|          _|          _|  _|_|      
_|    _|  _|          _|      _|    _|  _|  _|    
  _|_|    _|        _|_|_|_|    _|_|    _|    _|  
                                                                                                    
*/ 
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
//#define ls (rt&lt;&lt;1)
//#define rs (rt&lt;&lt;1|1)
#define vi vector&lt;int&gt;
#define pb push_back
#define mk make_pair
#define pii pair&lt;int,int&gt;
#define rep(i,a,b) for(int i=(a),i##end=(b);i&lt;=i##end;i++)
#define fi first
#define se second
typedef long long ll;
using namespace std;
const int maxn=2*2e3+100;
const int base=2000;
const int s=maxn-2,t=maxn-1;
const int inf=1e9+100;
int head[maxn];
pii ori[maxn];
int cnt=1;
struct gg{
	int u,v,w,idx,next;
}side[maxn*4];
void ins(int u,int v,int w,int idx){
	side[++cnt]=(gg){u,v,w,idx,head[u]};head[u]=cnt;
	side[++cnt]=(gg){v,u,0,idx,head[v]};head[v]=cnt;
}
int d[maxn];
vector&lt;vi&gt;ans;
int cur[maxn],rk[maxn];
queue&lt;int&gt;q;
bool bfs(){
	memset(rk,0,sizeof(rk));while(!q.empty())q.pop();
	q.push(s);rk[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=head[u];i;i=side[i].next){
			int v=side[i].v;if(rk[v]||!side[i].w)continue;
			rk[v]=rk[u]+1;q.push(v);
		}
	}
	if(rk[t])return 1;
	return 0;
}
int dfs(int u,int flow){
	if(u==t||!flow)return flow;
	int tot=0;
	for(int &amp;i=cur[u];i;i=side[i].next){
		int v=side[i].v;if(side[i].w&lt;=0||rk[v]!=rk[u]+1)continue;
		int sent=dfs(v,min(flow,side[i].w));
		//cout&lt;&lt;v&lt;&lt;&quot;----------&gt;&quot;&lt;&lt;u&lt;&lt;&quot;   flow=&quot;&lt;&lt;sent&lt;&lt;endl;
		flow-=sent,tot+=sent;side[i].w-=sent,side[i^1].w+=sent;
		if(!flow)break;
	}
	return tot;
}
void dinic(){
	while(bfs()){
		memcpy(cur,head,sizeof(head));
		dfs(s,inf);		
	}
}
int n1,n2,m;
void debug(){
	rep(i,1,n1)for(int j=head[i];j;j=side[j].next)cout&lt;&lt;&quot;&gt;&gt;&quot;&lt;&lt;side[j].u&lt;&lt;' '&lt;&lt;side[j].v&lt;&lt;' '&lt;&lt;side[j].w&lt;&lt;endl;
	rep(i,1,n2)for(int j=head[i+base];j;j=side[j].next)cout&lt;&lt;&quot;&gt;&gt;&quot;&lt;&lt;side[j].u&lt;&lt;' '&lt;&lt;side[j].v&lt;&lt;' '&lt;&lt;side[j].w&lt;&lt;endl;
	for(int j=head[s];j;j=side[j].next)cout&lt;&lt;&quot;&gt;&gt;&quot;&lt;&lt;side[j].u&lt;&lt;' '&lt;&lt;side[j].v&lt;&lt;' '&lt;&lt;side[j].w&lt;&lt;endl;
	cout&lt;&lt;&quot;END&quot;&lt;&lt;endl;
}
int main(){
	ios::sync_with_stdio(0);
	cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;
	int mi_d=1e9,mx_d=0;
	rep(i,1,m){
		int u,v;cin&gt;&gt;u&gt;&gt;v;ori[i]=mk(u,v);d[u]++,d[v+base]++;
		ins(u,v+base,1,i);
	}
	rep(i,1,n1)mi_d=min(mi_d,d[i]),mx_d=max(mx_d,d[i]);
	rep(i,1,n2)mi_d=min(mi_d,d[i+base]),mx_d=max(mx_d,d[i+base]);
	//容量 \in [u_degree-mi_degree,u_degree];
	rep(i,1,n1){
		ins(s,i,d[i]-mi_d-1,0);
	}
	rep(i,1,n2){
		ins(i+base,t,d[i+base]-mi_d-1,0);
	}
	
	//debug();
	for(int k=mi_d;k&gt;=0;k--){
		for(int i=head[s];i;i=side[i].next){
			//int v=side[i].v;
			if(!side[i].idx)side[i].w++;
		}
		rep(i,1,n2){
			for(int j=head[i+base];j;j=side[j].next){
				int v=side[j].v;
				if(!side[j].idx&amp;&amp;v==t)side[j].w++;
			}
		}
	//	debug();
		dinic();
		vi tmp;vi jk;
		rep(gg,base+1,base+n2)for(int i=head[gg];i;i=side[i].next)
		if(side[i].idx&amp;&amp;side[i].v&lt;=n1&amp;&amp;side[i].w)
		tmp.pb(side[i].idx);
		sort(tmp.begin(),tmp.end());
		int now=0;
		rep(i,1,m){
			if(now&lt;tmp.size()&amp;&amp;tmp[now]==i){
				now++;continue;
			}
			jk.pb(i);
		}
		ans.pb(jk);
	}
	for(int i=ans.size()-1;i&gt;=0;i--){
		vi tmp=ans[i];cout&lt;&lt;tmp.size()&lt;&lt;' ';
		rep(j,0,tmp.size()-1)cout&lt;&lt;tmp[j]&lt;&lt;' ';
		cout&lt;&lt;endl;
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF587E Duff as a Queen]]></title>
        <id>https://wzmhtr.coding-pages.com/post/cf587e-duff-as-a-queen/</id>
        <link href="https://wzmhtr.coding-pages.com/post/cf587e-duff-as-a-queen/">
        </link>
        <updated>2021-01-13T01:14:50.000Z</updated>
        <content type="html"><![CDATA[<p>一道经典套路题。<br>
首先考虑操作二，这个东西显然可以线性基。而线性基是可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的合并的，线段树维护暴力<code>push_up</code>即可。</p>
<p>然后考虑操作一，因为线性基无法删除/修改元素，所以维护时如果遇到元素修改，我们只能重建整个线性基。因此从复杂度的角度来讲我们只能进行单点修改操作。区间修改变成单点修改，很容易想到差分。所以我们线段树维护的是差分序列。</p>
<p>令序列A的线性基为A'，序列B的线性基为B'。如果A中的每个数都能被B中的一个子集异或得到，且B中的每个数都能被A中的一个子集异或得到，那就有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><msup><mi>B</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">A&#x27;=B&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>。我们考虑对于原序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的线性基，差分序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l+1,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的线性基再插入原序列的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>l</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,l]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span>得到的线性基和它是等价的。所以查询也能查询了。</p>
<p>这道题的套路就是用线段树维护区间的线性基，以及区间异或转差分。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二维数点问题及其变形]]></title>
        <id>https://wzmhtr.coding-pages.com/post/er-wei-shu-dian-wen-ti-ji-qi-bian-xing/</id>
        <link href="https://wzmhtr.coding-pages.com/post/er-wei-shu-dian-wen-ti-ji-qi-bian-xing/">
        </link>
        <updated>2021-01-12T00:39:49.000Z</updated>
        <content type="html"><![CDATA[<p>其实最早开始用主席树二位数点是两年前了。一直没有坐下来归纳一下二位数点的各种变形以及最优秀的实现方法。</p>
<h2 id="单点加-矩形查">单点加 矩形查</h2>
<p>离线做法：<br>
最简单的方法应该是扫描线。即维护一个序列数据结构（一般是树状数组/线段树）。序列数据结构上每个位置代表的值就是这个位置扫描过的区域（一条水平线段，开头在第一列）的点数。把每个矩形查询询问拆成两部分，用后面的减去前面的面积。<br>
比如我们需要统计蓝色区域面积：<br>
<img src="https://i.loli.net/2021/01/12/eY4p5ImXU6k3rOJ.png" alt="" loading="lazy"><br>
我们就使用粉色区域面积<br>
<img src="https://i.loli.net/2021/01/12/iZcerlonayYPfmW.png" alt="" loading="lazy"><br>
减去红色区域面积即可<br>
<img src="https://i.loli.net/2021/01/12/5Ej9K3af7R4UsSz.png" alt="" loading="lazy"><br>
而我们这里的面积实际上就是每一行做前缀和之后一个区间的和。用树状数组/线段树很好维护。<br>
半在线做法（在线询问 离线插入）：<br>
一般用主席树。对于一个离散化之后的点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>。我们令它第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>个插入，插入的值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。然后直接询问矩形即可。</p>
<h2 id="矩形加-单点查">矩形加 单点查</h2>
<p>只需要把矩形加转化为4次单点加（近似长方形四个顶点，但是有一些偏移）：<br>
左上角的点是长方形的顶点，右上角是长方形顶点向右移动一格，左下角是顶点向下移动一格，右下角是顶点向右下分别移动一格。<br>
<img src="https://i.loli.net/2021/01/12/46OPUxGQbW5NVIl.png" alt="" loading="lazy"><br>
然后如果我们需要查询红色点，只要询问红色点的前缀矩形（即蓝色矩形）即可。<br>
<img src="https://i.loli.net/2021/01/12/7WkRAptFXdos2HY.png" alt="" loading="lazy"><br>
这就转化成了单点加 矩形查的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF494D Birthday]]></title>
        <id>https://wzmhtr.coding-pages.com/post/cf494d-birthday/</id>
        <link href="https://wzmhtr.coding-pages.com/post/cf494d-birthday/">
        </link>
        <updated>2021-01-10T11:10:43.000Z</updated>
        <content type="html"><![CDATA[<p>先简述一下题意：定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>为以1号点为根时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>点到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>子树内的所有点的距离的平方和减去<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>点到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>点子树外的所有点的平方和。多次询问，可以离线。</p>
<p>我们先试着考虑离线询问然后换根。同时维护以当前点为根，每个点到其子树内所有点的距离的和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">sum1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">1</span></span></span></span>,距离的平方和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">sum2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">2</span></span></span></span>以及子树大小<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">size</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span></span></span></span>。</p>
<p>考虑如何维护。我们定义函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">trans(u,val)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>表示让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mn>2</mn><mo>(</mo><mi>u</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">sum2(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span></span></span></span>从子树内每个点距离的平方和变成子树内每个点距离加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>的平方和。根据初中数学知识就有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo>)</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mn>2</mn><mo>(</mo><mi>u</mi><mo>)</mo><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>×</mo><mi>v</mi><mi>a</mi><msup><mi>l</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mo>×</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo>×</mo><mi>s</mi><mi>u</mi><mi>m</mi><mn>1</mn><mo>(</mo><mi>u</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">trans(u,val)=sum2(u)+size\times val^2+2\times val\times sum1(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span></span></span></span>。知道了这个以后，如何维护就很简单了，大家可以自己推推看。</p>
<p>然后考虑维护了这个东西之后如何求解答案。对于询问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>来说，当以1为根时，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>不在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>子树内，那当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>为根时,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>换根前的子树一定等于换根后的子树。答案就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><mo>)</mo><mo>−</mo><mo>(</mo><mi>s</mi><mi>u</mi><mi>m</mi><mn>2</mn><mo>(</mo><mi>u</mi><mo>)</mo><mo>−</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">ans=trans(v,dis(u,v))-(sum2(u)-trans(v,dis(u,v)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p>
<p>然后我们考虑换根前，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>子树内的情况。令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>换根前的父亲为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">fa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span></span></span></span>，答案就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><mo>(</mo><mi>s</mi><mi>u</mi><mi>m</mi><mn>2</mn><mo>(</mo><mi>u</mi><mo>)</mo><mo>−</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mo>(</mo><mi>f</mi><mi>a</mi><mo separator="true">,</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>f</mi><mi>a</mi><mo separator="true">,</mo><mi>u</mi><mo>)</mo><mo>)</mo><mo>)</mo><mo>−</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mo>(</mo><mi>f</mi><mi>a</mi><mo separator="true">,</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>f</mi><mi>a</mi><mo separator="true">,</mo><mi>u</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">ans=(sum2(u)-trans(fa,dis(fa,u)))-trans(fa,dis(fa,u))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p>
<p>不需要任何高级数据结构，只需要一个倍增即可。（卓为啥要把这道题放数据结构专题啊喂）</p>
<pre><code class="language-cpp">/*
                                                  
  _|_|                              _|  _|    _|  
_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|    
_|    _|  _|_|          _|          _|  _|_|      
_|    _|  _|          _|      _|    _|  _|  _|    
  _|_|    _|        _|_|_|_|    _|_|    _|    _|  
                                                                                                    
*/ 
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
//#define ls (rt&lt;&lt;1)
//#define rs (rt&lt;&lt;1|1)
#define vi vector&lt;int&gt;
#define pb push_back
#define mk make_pair
#define pii pair&lt;int,int&gt;
#define rep(i,a,b) for(int i=(a),i##end=(b);i&lt;=i##end;i++)
#define fi first
#define se second
typedef long long ll;
using namespace std;
const int maxn=1e5+100;
const int mod=1e9+7;
ll sum1[maxn],sum2[maxn],size[maxn];
int dfn[maxn],dfncnt,f[maxn][20],d[maxn][20],n,dep[maxn];
vi side[maxn],w[maxn];
int trans(int u,int val){
	return (sum2[u]+size[u]*val%mod*val%mod+2*val*sum1[u]%mod)%mod;
}
void dfs1(int u,int fa){
	f[u][0]=fa;dfn[u]=++dfncnt;size[u]=1;dep[u]=dep[fa]+1;
	for(int i=0;i&lt;side[u].size();i++){
		int v=side[u][i];if(v==fa)continue;
		dfs1(v,u);size[u]+=size[v];d[v][0]=w[u][i];
		sum1[u]=(sum1[u]+sum1[v]+w[u][i]*size[v]%mod)%mod;
		sum2[u]=(sum2[u]+trans(v,w[u][i]))%mod;
	}
}
void init(){
	rep(i,1,19)rep(j,1,n)f[j][i]=f[f[j][i-1]][i-1];
	rep(i,1,19)rep(j,1,n)d[j][i]=(d[j][i-1]+d[f[j][i-1]][i-1])%mod;
}
int get_dis(int u,int v){
	ll ans=0;
	if(dep[u]&lt;dep[v])swap(u,v);
	for(int i=19;i&gt;=0;i--)if(dep[f[u][i]]&gt;=dep[v])ans=(ans+d[u][i])%mod,u=f[u][i];
	if(u==v)return ans;
	for(int i=19;i&gt;=0;i--)if(f[u][i]!=f[v][i])ans=(1ll*ans+d[u][i]+d[v][i])%mod,u=f[u][i],v=f[v][i];
	return (1ll*ans+d[u][0]+d[v][0])%mod;
}
struct Query{
	int u,v,idx;
	bool insubtree;
}q[maxn];
int ans[maxn];
bool cmp(Query a,Query b){return dfn[a.u]&lt;dfn[b.u];}
int now=1,t;
void dfs2(int u,int fa){
	while(now&lt;=t&amp;&amp;q[now].u==u){
		int v=q[now].v,idx=q[now].idx;
		if(q[now].insubtree){
			ans[idx]=(sum2[u]-2*trans(f[v][0],get_dis(f[v][0],u)))%mod;
			ans[idx]=(ans[idx]+mod)%mod;
		}
		else{
			ans[idx]=(2*trans(v,get_dis(u,v))-sum2[u])%mod;
			ans[idx]=(ans[idx]+mod)%mod;
		}
		now++;
	}
	for(int i=0;i&lt;side[u].size();i++){
		int v=side[u][i];if(v==fa)continue;
		ll bku1=sum1[u],bku2=sum2[u],bku3=size[u];
		ll bkv1=sum1[v],bkv2=sum2[v],bkv3=size[v];
		int tmp1=trans(v,w[u][i]),tmp2=trans(u,w[u][i])-trans(v,2*w[u][i]%mod);tmp2=(tmp2%mod+mod)%mod;
		sum1[u]=(bku1-(bkv1+w[u][i]*bkv3)%mod)%mod;sum1[u]=(sum1[u]%mod+mod)%mod;
		sum1[v]=((bku1-(bkv1+w[u][i]*bkv3)%mod)+(bku3-bkv3)*w[u][i]%mod+bkv1)%mod;sum1[v]=(sum1[v]%mod+mod)%mod;
		
		sum2[u]=(bku2-tmp1)%mod;sum2[u]=(sum2[u]%mod+mod)%mod;
		sum2[v]=tmp2+bkv2;sum2[v]=(sum2[v]%mod+mod)%mod;
		
		size[u]=bku3-bkv3;size[v]=bku3;
		dfs2(v,u);
		sum1[u]=bku1,sum2[u]=bku2,size[u]=bku3;
		sum1[v]=bkv1,sum2[v]=bkv2,size[v]=bkv3;
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin&gt;&gt;n;
	rep(i,1,n-1){
		int u,v,val;cin&gt;&gt;u&gt;&gt;v&gt;&gt;val;
		side[u].pb(v);w[u].pb(val);
		side[v].pb(u);w[v].pb(val);
	}
	dfs1(1,0);
	init();cin&gt;&gt;t;
	rep(i,1,t){
		cin&gt;&gt;q[i].u&gt;&gt;q[i].v;q[i].idx=i;
		if(dfn[q[i].v]&lt;=dfn[q[i].u]&amp;&amp;dfn[q[i].u]&lt;=dfn[q[i].v]+size[q[i].v]-1)q[i].insubtree=1;
	}
	sort(q+1,q+1+t,cmp);
	dfs2(1,0);
	rep(i,1,t){
		cout&lt;&lt;(ans[i]%mod+mod)%mod&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1140F Extending Set of Points]]></title>
        <id>https://wzmhtr.coding-pages.com/post/cf1140f-extending-set-of-points/</id>
        <link href="https://wzmhtr.coding-pages.com/post/cf1140f-extending-set-of-points/">
        </link>
        <updated>2021-01-08T13:06:24.000Z</updated>
        <content type="html"><![CDATA[<p>一看到二维点之间的关系，首先考虑下转化成二分图的形式。即左边的点代表行，右边的点代表列，二分图的边代表原图上的点。题目描述的规则就变成了：对于任意一条边连接的点对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>，与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>点之间有边的点集为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>，与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>点之间有边的点集为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>。 那么点集<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>中的点必定两两有边。所以对于一个二分图上连通块，二分图两边的点必定有边。</p>
<p>因为题意中的点是一个一个加入的，那就相当于每次加入一条边。我们只需要合并这两个边连接的连通块就好了。因为我们需要数二分图有多少边，所以我们需要只需要维护一下一个连通块左边和右边分别有多少个点即可。</p>
<p>问题转化为了：每次加边/删边，询问连通块的一些信息。那么显然用一个按秩合并可撤销并查集+线段树分治即可。</p>
<pre><code class="language-cpp">/*
                                                  
  _|_|                              _|  _|    _|  
_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|    
_|    _|  _|_|          _|          _|  _|_|      
_|    _|  _|          _|      _|    _|  _|  _|    
  _|_|    _|        _|_|_|_|    _|_|    _|    _|  
                                                                                                    
*/ 
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#define ls (rt&lt;&lt;1)
#define rs (rt&lt;&lt;1|1)
#define vi vector&lt;int&gt;
#define pb push_back
#define mk make_pair
#define pii pair&lt;int,int&gt;
#define rep(i,a,b) for(int i=(a),i##end=(b);i&lt;=i##end;i++)
#define fi first
#define se second
typedef long long ll;
using namespace std;
const int maxn=3e5+1000;
map&lt;pii,int&gt;lst;
ll tmpans;
struct dsu{
	int fa[2*maxn],size[2*maxn],rowsize[2*maxn],colsize[2*maxn];
	//row points idx :i
	//col  points idx:i+maxn 
	pii his[maxn];//&lt;son,fa&gt;
	int top;
	dsu(){
		top=0;
		rep(i,0,maxn*2-1)fa[i]=i,size[i]=1;
		rep(i,1,maxn)rowsize[i]=1,colsize[i+maxn]=1;
	}
	int get(int x){return (fa[x]==x)?x:get(fa[x]);}
	void merge(int s,int f){
		s=get(s),f=get(f);
		if(size[s]&gt;size[f])swap(s,f);
		tmpans-=1ll*rowsize[f]*colsize[f]+1ll*rowsize[s]*colsize[s];
		size[f]+=size[s];rowsize[f]+=rowsize[s];colsize[f]+=colsize[s];
		tmpans+=1ll*rowsize[f]*colsize[f];
		fa[s]=f;his[++top]=mk(s,f);
	}
	void roll_back(int n){
		rep(i,1,n){
			int f=his[top].se,s=his[top].fi;top--;
			tmpans-=1ll*rowsize[f]*colsize[f];
			size[f]-=size[s];rowsize[f]-=rowsize[s];colsize[f]-=colsize[s];
			tmpans+=1ll*rowsize[f]*colsize[f]+1ll*rowsize[s]*colsize[s];
			fa[s]=s;
		}
	}
}d;
ll ans[maxn];

struct segment_tree{
	vector&lt;pii&gt; tag[maxn&lt;&lt;2];
	void add_op(int l,int r,int rt,int tl,int tr,pii val){
		if(tl&lt;=l&amp;&amp;r&lt;=tr){
			tag[rt].pb(val);return;
		}
		int mid=(l+r)&gt;&gt;1;
		if(tl&lt;=mid)add_op(l,mid,ls,tl,tr,val);
		if(tr&gt;=mid+1)add_op(mid+1,r,rs,tl,tr,val);
	}
	void vamos(int l,int r,int rt){
		int cnt=0;
	//	cout&lt;&lt;&quot;IN:&quot;&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;' '&lt;&lt;tmpans&lt;&lt;endl;
		for(int i=0;i&lt;tag[rt].size();i++){
			pii tmp=tag[rt][i];
			if(d.get(tmp.fi)!=d.get(tmp.se+maxn)){
				d.merge(tmp.fi,tmp.se+maxn);cnt++;
			}
		}
		if(l==r){ans[l]=tmpans;d.roll_back(cnt);return;}
		int mid=(l+r)&gt;&gt;1;
		vamos(l,mid,ls);
		vamos(mid+1,r,rs);
		d.roll_back(cnt);
		//cout&lt;&lt;&quot;OUT:&quot;&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;' '&lt;&lt;tmpans&lt;&lt;endl;
		int gg=1;
	}
}t;
vector&lt;pii&gt;res;
int main(){
	ios::sync_with_stdio(0);
	int q;cin&gt;&gt;q;
	rep(i,1,q){
		pii tmp;cin&gt;&gt;tmp.fi&gt;&gt;tmp.se;res.pb(tmp);
		if(lst[tmp]){
			t.add_op(1,q,1,lst[tmp],i-1,tmp);
			lst[tmp]=0;
		}else{
			lst[tmp]=i;
		}
	}
	for(int i=0;i&lt;res.size();i++){
		pii tmp=res[i];
		if(lst[tmp]){
			t.add_op(1,q,1,lst[tmp],q,tmp);
			lst[tmp]=0;
		}
	}
	t.vamos(1,q,1);
	rep(i,1,q)cout&lt;&lt;ans[i]&lt;&lt;' ';
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[exgcd]]></title>
        <id>https://wzmhtr.coding-pages.com/post/exgcd/</id>
        <link href="https://wzmhtr.coding-pages.com/post/exgcd/">
        </link>
        <updated>2020-11-06T06:59:04.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">void exgcd(int a, int b, int&amp; d, int&amp; x, int&amp; y) {
    if(b) exgcd(b, a % b, d, y, x), y -= a / b * x;
    else d = a, x = 1, y = 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斜率优化-李超线段树维护凸包]]></title>
        <id>https://wzmhtr.coding-pages.com/post/xie-lu-you-hua-li-chao-xian-duan-shu-wei-hu-tu-bao/</id>
        <link href="https://wzmhtr.coding-pages.com/post/xie-lu-you-hua-li-chao-xian-duan-shu-wei-hu-tu-bao/">
        </link>
        <updated>2020-10-28T07:39:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>遇到了一道矩形上的DP，点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>的处理过后的DP为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mrow><mi mathvariant="normal">∀</mi><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo separator="true">,</mo><msup><mi>j</mi><mo mathvariant="normal">′</mo></msup><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo separator="true">,</mo><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mi mathvariant="normal">≠</mi><mo>(</mo><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>j</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow></mrow></msub><mo>(</mo><msub><mi>A</mi><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>(</mo><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>j</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">min_{\forall{i&#x27;&lt;=i,j&#x27;&lt;=j,(i,j)\neq(i&#x27;,j&#x27;)} }(A_{(i,j)(i&#x27;,j&#x27;)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∀</span><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mrel mtight">&lt;</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mrel mtight">&lt;</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span><span class="mrel mtight"><span class="mrel mtight"><span class="mord mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="rlap mtight"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel mtight"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel mtight">=</span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>(</mo><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>j</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">A_{(i,j)(i&#x27;,j&#x27;)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>u</mi><mi>f</mi><msub><mi>f</mi><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow></msub><mo>×</mo><mo>(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">buff_{(i,j)}\times (i+j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>。看柿子很斜率优化，但是二维平面上很不好整，打了个暴力就溜了。然后发现这题人均正解，还被教练嘲讽：“这不是套路题吗？”。嘤嘤嘤自闭了。</p>
<h2 id="套路">套路</h2>
<p>我们发现转移柿子是形如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mo>(</mo><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>j</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow></msub><mo>+</mo><msub><mi>b</mi><mrow><mo>(</mo><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>j</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow></msub><mo>×</mo><msub><mi>c</mi><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">a_{(i&#x27;,j&#x27;)}+b_{(i&#x27;,j&#x27;)}\times c_{(i,j)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9385299999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a,b,c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span></span></span></span>分别是只和一个点对相关的柿子。我们发现这是一个斜率优化：我们需要在很多状态中求最大值，而每个状态的大小是由自己本身的性质(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">k,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>)和变量组成的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>。（P.S. 如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>还乘了个和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>相关的柿子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>，可以把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>c</mi><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{c}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>然后把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>提出去）</p>
<p>但是我们考虑，这道题的直线并没有单调性，所以需要两层CDQ，可能还需要个动态凸包啥的（我也没细想）。于是我们考虑使用李超线段树。</p>
<p>李超线段树其实就是维护了一个凸包。凸包上的每条边都代表一个转移状态（一般斜率优化的状态在点上，当然也有状态在边上的写法）。当你确定一个自变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的时候，用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>这条直线去切凸包，切到的直线就是最优决策。还有一个问题就是这道题从哪里转移过来的限制是一个二维前缀。以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>递增的顺序计算DP值可以避免<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>坐标的访问越界，但是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>坐标无法避免。解决方案只有套个树状数组，树状数组每个节点都代表了一个区间，对每个树状数组节点都建个李超树即可。（其实就是树套树）</p>
<p>需要注意的是：我们用树状数组维护的那一维是尽量小的那一维，这样我们的时间就能少一些。<br>
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>m</mi><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">nm\log _2{min(m,n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span><br>
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>m</mi><msubsup><mi>log</mi><mo>⁡</mo><mn>2</mn><mn>2</mn></msubsup><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">nm\log _2^2{min(m,n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148448em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span><br>
代码：</p>
<pre><code class="language-cpp">/*
                                                  
  _|_|                              _|  _|    _|  
_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|    
_|    _|  _|_|          _|          _|  _|_|      
_|    _|  _|          _|      _|    _|  _|  _|    
  _|_|    _|        _|_|_|_|    _|_|    _|    _|  
                                                                                                    
*/ 
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
//#define ls (rt&lt;&lt;1)
//#define rs (rt&lt;&lt;1|1)
#define vi vector&lt;int&gt;
#define pb push_back
#define mk make_pair
#define pii pair&lt;int,int&gt;
#define rep(i,a,b) for(int i=(a),i##end=(b);i&lt;=i##end;i++)
#define fi first
#define se second
typedef long long ll;
using namespace std;
const int maxn=1e5+1000;
const ll inf=1e18;
int buff[maxn],val[maxn];
int bk1[maxn],bk2[maxn];
int n,m;
int get_id(int i,int j,int g=m){return (i-1)*g+j;}
struct line{
	int k;ll b;
	ll get(int x){return 1ll*x*k+b;}
};
line mk_l(int k,ll b){line tmp;tmp.k=k,tmp.b=b;return tmp;}
struct li_chao_segment_tree_in_a_BIT{
	line val[maxn*100];
	int cnt,rt[330],ls[maxn*100],rs[maxn*100];
	void ins(int &amp;idx,int l,int r,line L){
		if(!idx){idx=++cnt;val[idx]=L;return;}
		int mid=(l+r)&gt;&gt;1;
		if(val[idx].get(mid)&lt;L.get(mid))swap(val[idx],L);
		if(val[idx].get(l)&lt;L.get(l))ins(ls[idx],l,mid,L);
		if(val[idx].get(r)&lt;L.get(r))ins(rs[idx],mid+1,r,L);
	}
	ll query(int idx,int l,int r,int x){
		if(!idx)return 0;
		ll res=val[idx].get(x);
		if(l==r)return res;
		int mid=(l+r)&gt;&gt;1;
		return max(res,(x&lt;=mid)?query(ls[idx],l,mid,x):query(rs[idx],mid+1,r,x));
	}
	void ins(int loc,line L){
		for(int i=loc;i&lt;=m;i+=i&amp;(-i))ins(rt[i],1,n+m,L);
	}
	ll query(int loc,int x){
		ll ans=-inf;
		for(int i=loc;i;i-=i&amp;(-i))ans=max(ans,query(rt[i],1,n+m,x));
		return ans;
	} 
}t;
ll dp[maxn];
ll g(int i,int j){return dp[get_id(i,j)]-1ll*buff[get_id(i,j)]*(i+j);}
int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	rep(i,1,n)rep(j,1,m)scanf(&quot;%d&quot;,&amp;buff[get_id(i,j)]);
	rep(i,1,n)rep(j,1,m)scanf(&quot;%d&quot;,&amp;val[get_id(i,j)]);
	if(n&lt;m){//m作为树状数组的维度 应该尽量小
		rep(i,1,m)rep(j,1,n)bk1[get_id(i,j,n)]=buff[get_id(j,i)],bk2[get_id(i,j,n)]=val[get_id(j,i)];
		swap(n,m);rep(i,1,n*m)buff[i]=bk1[i],val[i]=bk2[i];
	}
	memset(dp,-0x3f,sizeof(dp));
	dp[get_id(1,1)]=0;t.ins(1,mk_l(buff[get_id(1,1)],g(1,1)));
	rep(i,1,n)rep(j,1,m)if(i!=1||j!=1){
		int idx=get_id(i,j);
		dp[idx]=t.query(j,i+j)+val[idx];
		t.ins(j,mk_l(buff[idx],g(i,j)));
	}
	cout&lt;&lt;dp[get_id(n,m)];
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>